const { useState, useEffect, useMemo, useCallback, useRef, createContext, useContext } = React;
const { Search, Plus, Upload, Download, Settings, BarChart, Users, Moon, Sun, ChevronLeft, ChevronRight, Volume2, VolumeX, Image, Mic, X, Check, AlertCircle, Clock, Brain, Zap, Target, Award, TrendingUp, Calendar, BookOpen, Shuffle, RotateCw, Play, Pause, ChevronDown, ChevronUp, Edit, Trash2, Copy, Filter, Tag, Layers, Grid, List, Move, ArrowUp, ArrowDown, Menu, Home } = lucide;

// ==================== Types & Classes ====================
class SpacedRepetitionAlgorithm {
  static MIN_EASE_FACTOR = 1.3;
  static EASY_BONUS = 1.3;
  static HARD_PENALTY = 0.8;
  
  calculateInterval(card, quality) {
    const updatedCard = { ...card };
    
    if (quality < 3) {
      updatedCard.interval = 1;
      updatedCard.repetitions = 0;
      updatedCard.lapses++;
    } else {
      if (updatedCard.repetitions === 0) {
        updatedCard.interval = 1;
      } else if (updatedCard.repetitions === 1) {
        updatedCard.interval = 6;
      } else {
        updatedCard.interval = Math.round(updatedCard.interval * updatedCard.easeFactor);
      }
      updatedCard.repetitions++;
    }
    
    updatedCard.easeFactor = Math.max(
      SpacedRepetitionAlgorithm.MIN_EASE_FACTOR,
      updatedCard.easeFactor + 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)
    );
    
    if (quality === 5) {
      updatedCard.interval = Math.round(updatedCard.interval * SpacedRepetitionAlgorithm.EASY_BONUS);
    } else if (quality === 3) {
      updatedCard.interval = Math.round(updatedCard.interval * SpacedRepetitionAlgorithm.HARD_PENALTY);
    }
    
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + updatedCard.interval);
    updatedCard.nextReview = nextReviewDate.toISOString();
    updatedCard.lastStudied = new Date().toISOString();
    
    return updatedCard;
  }
  
  getCardsForReview(cards) {
    const now = new Date();
    return cards.filter(card => {
      if (!card.nextReview) return true;
      return new Date(card.nextReview) <= now;
    }).sort((a, b) => {
      if (a.lapses !== b.lapses) return b.lapses - a.lapses;
      return a.interval - b.interval;
    });
  }
}

class SpeechService {
  static synthesis = typeof window !== 'undefined' ? window.speechSynthesis : null;
  static currentUtterance = null;
  
  static isSupported() {
    return typeof window !== 'undefined' && 'speechSynthesis' in window;
  }
  
  static getVoices() {
    return this.synthesis?.getVoices() || [];
  }
  
  static speak(text, settings) {
    return new Promise((resolve, reject) => {
      if (!this.isSupported() || !settings.speechEnabled || !this.synthesis) {
        resolve();
        return;
      }
      
      this.stop();
      
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = settings.speechRate;
      
      const voices = this.getVoices();
      const selectedVoice = voices.find(v => v.name === settings.speechVoice);
      if (selectedVoice) {
        utterance.voice = selectedVoice;
      }
      
      utterance.onend = () => {
        this.currentUtterance = null;
        resolve();
      };
      
      utterance.onerror = (error) => {
        this.currentUtterance = null;
        reject(error);
      };
      
      this.currentUtterance = utterance;
      this.synthesis.speak(utterance);
    });
  }
  
  static stop() {
    if (this.synthesis?.speaking) {
      this.synthesis.cancel();
    }
    this.currentUtterance = null;
  }
  
  static isSpeaking() {
    return this.synthesis?.speaking || false;
  }
}

class StorageService {
  static STORAGE_KEY = 'flashcards-pro-enhanced';
  
  static save(state) {
    try {
      const data = {
        ...state,
        categories: Array.from(state.categories),
      };
      localStorage.setItem(this.STORAGE_KEY, JSON.stringify(data));
    } catch (error) {
      console.error('Failed to save data:', error);
    }
  }
  
  static load() {
    try {
      const data = localStorage.getItem(this.STORAGE_KEY);
      if (!data) return null;
      
      const parsed = JSON.parse(data);
      return {
        ...parsed,
        categories: new Set(parsed.categories || []),
      };
    } catch (error) {
      console.error('Failed to load data:', error);
      return null;
    }
  }
  
  static exportData(state) {
    const data = {
      version: '3.0',
      exported: new Date().toISOString(),
      ...state,
      categories: Array.from(state.categories),
    };
    
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `flashcards-pro-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
}

// ==================== Context ====================
const FlashCardsContext = createContext(null);

const useFlashCards = () => {
  const context = useContext(FlashCardsContext);
  if (!context) throw new Error('useFlashCards must be used within FlashCardsProvider');
  return context;
};

//
